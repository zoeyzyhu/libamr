diff --git a/python/actor.py b/python/actor.py
index 3aae4da..8282418 100644
--- a/python/actor.py
+++ b/python/actor.py
@@ -9,7 +9,6 @@ import ray
 from ray import ObjectRef
 import numpy as np
 import mesh as me
-import random
 
 
 def check_neighbor_ready(func):
@@ -30,9 +29,6 @@ def check_neighbor_ready(func):
     return wrapper
 
 
-def diffusion_2d(arr):
-    return arr[1:-1,:-2] + arr[1:-1,2:] + arr[2:,1:-1] + arr[:-2,1:-1] - 4. * arr[1:-1,1:-1]
-
 @ray.remote(num_cpus=1)
 class MeshBlockActor:
     """Remotely launch actors as mesh blocks."""
@@ -65,11 +61,13 @@ class MeshBlockActor:
         """Reset the status of the mesh block."""
         self.mblock.is_ready = False
 
-    def work(self) -> int:
+    def work(self) -> None:
         """Update the interior of the mesh block."""
         start_time = time.time()
+        target_duration = 150  # seconds
 
-        self.run_stencil()
+        while time.time() - start_time < target_duration:
+            self.run_stencil()
 
         stime = datetime.fromtimestamp(
             start_time).strftime('%Y-%m-%d %H:%M:%S')
@@ -84,48 +82,29 @@ class MeshBlockActor:
             f.write(f"Duration: {duration} seconds\n")
 
         thresholds = (0.2, 0.8)  # coarsen, refine
-        return self.check_refine(*thresholds)
-
-    def run_stencil(self, kernel_func = diffusion_2d) -> None:
+        point = self.mblock.size.center()
+        x = np.random.rand(1)
+        if x[0] < thresholds[0]:
+            return -1, point  # coarsen
+        # if x[0] > thresholds[1]:
+        #    return 1, point  # refine
+        return 0, point
+
+    def run_stencil(self) -> None:
         """Calculate stencil for interior block."""
         if not self.mblock.is_ready:
             raise ValueError("interior matrix is not ready")
 
-        level = floor(log2(self.logicloc[2]))
-
-        diffusivity = min(0.0000001 * (2 ** level), 1.)
-        iter_time = 10000 * level
-        key = (0,0,0)
-
-        for n in range(iter_times):
-            self.ghost[key] += diffusivity * kernel_func(self.mblock.data)
-
-        #for n in range(10):
-        #    i = random.randint(0, self.mblock.size.nx1)
-        #    j = random.randint(0, self.mblock.size.nx2)
-        #    self.ghost[key][i,j] += np.random.normal(0, 10.) / level
-
-    def check_refine(low: float, high: float) -> int:
-        key = (0,0,0)
-
-        ddx = abs(self.mblock.data[1:-1,1:] - self.mblock.data[1:-1,:-1])
-        dx = self.mblock.coord.x1v[1] - self.mblock.coord.x1v[0]
-        ddx_min, ddx_max = ddx.min() / dx, ddx.max() / dx
-
-        if ddx_max > high:
-            return 1
-
-        ddy = abs(self.mblock.data[1:,1:-1] - self.mblock.data[:-1,1:-1])
-        dy = self.mblock.coord.x2v[1] - self.mblock.coord.x2v[0]
-        ddy_min, ddy_max = ddy.min() / dy, ddy.max() / dy
-
-        if ddy_max > high:
-            return 1
-
-        if ddx_min < low and ddy_min < low:
-            return -1
-
-        return 0
+        for row in range(self.mblock.size.nghost,
+                         self.mblock.size.nghost + self.mblock.size.nx1):
+            for col in range(self.mblock.size.nghost,
+                             self.mblock.size.nghost + self.mblock.size.nx2):
+                self.mblock.data[:, col, row] = \
+                    self.mblock.data[:, col, row + 1] \
+                    + self.mblock.data[:, col, row - 1] \
+                    + self.mblock.data[:, col + 1, row] \
+                    + self.mblock.data[:, col - 1, row] \
+                    - 4 * self.mblock.data[:, col, row]
 
     def put_data(self):
         """Put the mesh block in Plasma store."""
